Dos clases de momento:
- Una para crear las redes (Interaction Network)
- Otra para cada miembo (NetworkMember)

En la clase de interaction networks solo almacenas qué miembros, 
pero no cómo están unidos pues te da igual realmente.

Solo usar IntAct para buscar interacciones entre proteinas, 
y esta base de datos necesita del identificador de Uniprot, 
por lo q hay q convertir del AT... al identificador uniprot

El how deep es lo que dijimos, miras las que interaccionan 
y de esas miras sus interacciones, hasta depth 2

En el report pones o cuales de la lista comparten nework o 
directamente le printeas todos los miembros de la red

# tab25 formato:

# 1. id de UNIPROTKB interactor A (porque es IntAct van a ser siempre de uniprotkb) SI
# 2. id de UNIPROTKB interactor B (porque es IntAct van a ser siempre de uniprotkb) SI
# 3. otros identifiers ¿puede que sean útiles para GO o KEGG?
# 4. otros identifiers proteina B
# 5. Aliases : aquí está el locus name (uniprotkb:At4g18960) que es lo que nos da el profe: util para convertirlo en id de uniprot!! y luego ver cuales de la lista comparten network
# 6. Aliases: proteina B
# 7. Interaction detection method: habría que seleccionar de los que nos podemos fiar. Creo que SM y 2-hybrid son fiables, los modelos bioinformaticos/computacionales no son muy fiables porque habría que comprobarlos empiricamente
# 8. Autor: pasamos
# 9. ID publicacion: pasamos
# 10. ID TAXONOMY A: pasamos (filtramos por Athaliana)
# 11. ID TAXONOMY B: pasamos
# 12. Tipo de interacción: diría que pasamos 
# 13. DB de la que hemos sacado los datos: diría que tb pasamos 
# 14. ID de la interacción: no se... tb diria que pasamos pero nosé si sería bueno para filtrar y mergear redes, rollo: si encuentras esta interaccion en comun entonces mergea. Pero creo que no tiene mucho sentido porque es mejor mergear si hay protes comunes entiendo
# 15. Confidence score: importante: FILTRAR por calidad, habría que ver que valores ponemos, no sé si se puede filtrar en el query o hacemos filtros x codigo 

# He hecho muchas cosas, algunas las uso y otras no, las he puesto porque puede que nos sirvan en el futuro
# de momento mi código crea redes con miembros únicos a deph 1
# falta rescursividad
# falta kegg y GO
# falta filtrar y mergear las redes
# y falta ver una forma de como conectar el locus name con el identificador de uniprotkb ¿se puede hacer un has?

# lo más complicado de entender son las funciones ?eql, == y hash, esas son para comprobar que el objeto no esté ya en el hash
# creo q se podría haber hecho más sencillo pero bueno si tienes dudas lo hablamos